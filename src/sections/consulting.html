<!-- CONSULTING SECTION (SPA VERSION) -->

<!-- INTRO SECTION -->
<section id="intro" class="section section--white">
  <div class="section__inner">
    <header class="section__header">
      <h1 id="intro-title" class="section__title animate-fade-in animate-delay-1">컨설팅</h1>
      <p id="intro-subtitle" class="section__subtitle animate-fade-in animate-delay-2"></p>
    </header>
  </div>
</section>

<!-- SERVICE CATEGORIES -->
<section id="service-categories" class="section section--gradient">
  <div class="section__inner">
    <header class="section__header">
      <h2 class="section__title animate-fade-in animate-delay-1">컨설팅 서비스</h2>
    </header>

    <div id="service-grid" class="consulting-grid"></div>
  </div>
</section>

<!-- CONSULTING PROCESS -->
<section id="consulting-process" class="section section--white">
  <div class="section__inner">
    <div class="process-card animate-fade-in animate-delay-1">
      <h2 id="process-title" class="process-card__title">컨설팅 프로세스</h2>
      <div id="process-steps" class="process-grid"></div>
    </div>
  </div>
</section>

<!-- SECTION SCRIPT -->
<script>
document.addEventListener("DOMContentLoaded", async () => {
  // JSON 로드
  const res = await fetch("/src/js/data/consulting.json");
  const data = await res.json();

  /* INTRO RENDER */
  const introTitleEl = document.getElementById("intro-title");
  const introSubtitleEl = document.getElementById("intro-subtitle");

  if (data.intro) {
    introTitleEl.textContent = data.intro.title || "";
    introSubtitleEl.textContent = data.intro.subtitle || "";
  }

  /* SERVICE CATEGORIES */
  const serviceGrid = document.getElementById("service-grid");

  if (Array.isArray(data.serviceCategories)) {
    data.serviceCategories.forEach((cat, index) => {
      // 아이콘 색상 BEM 클래스 매핑
      const iconClassMap = {
        primary:   "consulting-card__icon consulting-card__icon--primary",
        secondary: "consulting-card__icon consulting-card__icon--secondary",
        purple:    "consulting-card__icon consulting-card__icon--purple",
        green:     "consulting-card__icon consulting-card__icon--green"
      };

      const iconClass =
        iconClassMap[cat.color] ||
        "consulting-card__icon consulting-card__icon--primary";

      const delay = cat.delay || (index + 1); // delay 없으면 순서 기반

      const card = document.createElement("article");
      card.className = "consulting-card animate-scale-in animate-delay-" + delay;

      card.innerHTML = `
        <div class="${iconClass}">
          <i class="${cat.icon || ""}"></i>
        </div>

        <h3 class="consulting-card__title">${cat.title || ""}</h3>
        <p class="consulting-card__desc">${cat.description || ""}</p>

        <ul class="consulting-card__list">
          ${
            (cat.items || [])
              .map(
                (item) =>
                  `<li><i class="ri-check-line"></i>${item}</li>`
              )
              .join("")
          }
        </ul>
      `;

      serviceGrid.appendChild(card);
    });
  }

  /* PROCESS RENDER */
  const processTitleEl = document.getElementById("process-title");
  const processGrid = document.getElementById("process-steps");

  if (data.process) {
    processTitleEl.textContent = data.process.title || "";

    if (Array.isArray(data.process.steps)) {
      data.process.steps.forEach((step, index) => {
        const delay = step.delay || (index + 1);
        const stepEl = document.createElement("div");
        stepEl.className =
          "process-step animate-scale-in animate-delay-" + delay;

        // 아이콘 색상은 순서를 기준으로 1~5 맵핑
        const iconVariant = (index % 5) + 1; // 1 ~ 5 반복
        const iconClass =
          "process-step__icon process-step__icon--" + iconVariant;

        stepEl.innerHTML = `
          <div class="${iconClass}">
            <i class="${step.icon || ""}"></i>
          </div>
          <h4 class="process-step__title">${step.title || ""}</h4>
          <p class="process-step__desc">${step.description || ""}</p>
        `;

        processGrid.appendChild(stepEl);
      });
    }
  }

  /* INTERSECTION OBSERVER (애니메이션 트리거) */
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          entry.target.classList.add("visible", "revealed");
        }
      });
    },
    { threshold: 0.1 }
  );

  // _home.scss에 정의된 애니메이션용 클래스들
  document
    .querySelectorAll(".animate-fade-in, .animate-slide-up, .animate-scale-in, .scroll-reveal")
    .forEach((el) => observer.observe(el));
});
</script>
